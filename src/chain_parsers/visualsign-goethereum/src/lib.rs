use crate::bindings::DecodeEthereumTransactionToJSON;
use crate::bindings::FreeString;
use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use visualsign::{
    SignablePayload,
    vsptrait::{
        Transaction, TransactionParseError, VisualSignConverter, VisualSignConverterFromString,
        VisualSignError, VisualSignOptions,
    },
};
// Include the generated bindings
// Include the FFI bindings generated by build.rs
#[allow(dead_code)]
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

// This is a demo implementation that shows how to use FFI to create a visualsign converter using go-ethereum library
// it creates a static library that can be used in the visualsign parser
#[derive(Debug, Clone)]
pub struct GoEthereumTransactionWrapper {
    raw_data: String,
}

impl Transaction for GoEthereumTransactionWrapper {
    fn from_string(data: &str) -> Result<Self, TransactionParseError> {
        Ok(Self {
            raw_data: data.to_string(),
        })
    }

    fn transaction_type(&self) -> String {
        "Ethereum".to_string()
    }
}

impl GoEthereumTransactionWrapper {
    pub fn new(raw_data: String) -> Self {
        Self { raw_data }
    }

    pub fn raw_data(&self) -> &str {
        &self.raw_data
    }
}

/// Converter for unspecified/unknown chains
pub struct GoEthereumVisualSignConverter;

impl VisualSignConverter<GoEthereumTransactionWrapper> for GoEthereumVisualSignConverter {
    fn to_visual_sign_payload(
        &self,
        transaction_wrapper: GoEthereumTransactionWrapper,
        _options: VisualSignOptions,
    ) -> Result<SignablePayload, VisualSignError> {
        // Call the Go FFI function to decode the transaction
        let raw_tx = transaction_wrapper.raw_data();

        // Convert Rust string to C string
        let c_tx = CString::new(raw_tx).map_err(|e| {
            VisualSignError::ParseError(TransactionParseError::InvalidFormat(format!(
                "Failed to create C string: {}",
                e
            )))
        })?;

        // Call the Go function via FFI
        let result_ptr = unsafe { DecodeEthereumTransactionToJSON(c_tx.as_ptr() as *mut c_char) };

        if result_ptr.is_null() {
            return Err(VisualSignError::ParseError(
                TransactionParseError::DecodeError("Go function returned null".to_string()),
            ));
        }

        // Convert the C string result back to Rust string
        let result_str = unsafe {
            let c_str = CStr::from_ptr(result_ptr);
            c_str.to_string_lossy().to_string()
        };

        // Free the C string returned by Go
        unsafe { FreeString(result_ptr) };

        // Parse the JSON response from Go
        let signable_payload: SignablePayload = serde_json::from_str(&result_str).map_err(|e| {
            VisualSignError::ParseError(TransactionParseError::DecodeError(format!(
                "Failed to parse JSON from Go: {}",
                e
            )))
        })?;

        Ok(signable_payload)
    }
}

impl VisualSignConverterFromString<GoEthereumTransactionWrapper> for GoEthereumVisualSignConverter {}

// Public API functions
pub fn transaction_to_visual_sign(
    raw_data: String,
    options: VisualSignOptions,
) -> Result<SignablePayload, VisualSignError> {
    let wrapper = GoEthereumTransactionWrapper::new(raw_data);
    let converter = GoEthereumVisualSignConverter;
    converter.to_visual_sign_payload(wrapper, options)
}

pub fn transaction_string_to_visual_sign(
    transaction_data: &str,
    options: VisualSignOptions,
) -> Result<SignablePayload, VisualSignError> {
    let converter = GoEthereumVisualSignConverter;
    converter.to_visual_sign_payload_from_string(transaction_data, options)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ffi_integration() {
        // Test with a known good transaction hex
        let test_tx = "0xf86c808504a817c800825208943535353535353535353535353535353535353535880de0b6b3a76400008025a028ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276a067cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83";

        let wrapper = GoEthereumTransactionWrapper::new(test_tx.to_string());
        let converter = GoEthereumVisualSignConverter;
        let options = VisualSignOptions::default();

        let result = converter.to_visual_sign_payload(wrapper, options);

        match result {
            Ok(payload) => {
                assert_eq!(payload.version, "0");
                assert_eq!(payload.title, "Ethereum Transaction");
                assert!(!payload.fields.is_empty(), "Should have decoded fields");
            }
            Err(e) => {
                eprintln!("FFI call failed with error: {:?}", e);
                panic!("FFI call should succeed but got error: {:?}", e);
            }
        }
    }

    #[test]
    fn test_transaction_to_visual_sign_public_api() {
        // Test the public API function
        let test_tx = "0xf86c808504a817c800825208943535353535353535353535353535353535353535880de0b6b3a76400008025a028ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276a067cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83";
        let options = VisualSignOptions::default();

        let result = transaction_to_visual_sign(test_tx.to_string(), options);

        match result {
            Ok(payload) => {
                assert_eq!(payload.title, "Ethereum Transaction");
            }
            Err(e) => {
                eprintln!("Public API failed with error: {:?}", e);
                panic!("Public API should work but got error: {:?}", e);
            }
        }
    }
}
